class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    def find(self, u): return u if self.parent[u] == u else self.find(self.parent[u])
    def union(self, u, v):
        root_u, root_v = self.find(u), self.find(v)
        if root_u != root_v: self.parent[root_v] = root_u
        return root_u != root_v

def kruskal(n, edges):
    uf, mst, mst_weight = UnionFind(n), [], 0
    for u, v, weight in sorted(edges, key=lambda x: x[2]):
        if uf.union(u, v):
            mst.append((u, v, weight))
            mst_weight += weight
    return mst, mst_weight

def check_unique_mst(n, edges, mst, mst_weight):
    mst_set = set((min(u, v), max(u, v)) for u, v, _ in mst)
    for u, v, weight in edges:
        if (min(u, v), max(u, v)) not in mst_set:
            uf, temp_mst, temp_weight = UnionFind(n), [], 0
            for edge in mst + [(u, v, weight)]:
                if uf.union(edge[0], edge[1]):
                    temp_mst.append(edge)
                    temp_weight += edge[2]
            if temp_weight == mst_weight:
                return False  # Found another MST with the same weight
    return True

# Example graph (edges with weight)
edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]
n = 4  # Number of vertices

mst, mst_weight = kruskal(n, edges)
if check_unique_mst(n, edges, mst, mst_weight):
    print("The MST is unique.")
else:
    print("The MST is not unique.")
